If you're using the Comparable interface approach, the class whose instances you want to compare should implement the Comparable interface. In this case, if we're comparing items in the cart, the class representing the items in the cart should implement Comparable.

To implement the compareTo() method to reflect the desired ordering, you would compare the current object (this) with the object being passed as an argument (otherObject). The method should return a negative integer if this object should come before otherObject, a positive integer if this object should come after otherObject, and zero if they are considered equal in terms of ordering.
To achieve multiple ordering rules (such as by title then by cost, and by cost then by title), you can create different instances of Comparator and use them with the Collections.sort() method whenever needed. However, with the Comparable interface, you're limited to a single ordering rule for objects of that class.

If you want to handle different ordering rules for different types of media, such as DVDs having a different ordering rule than other media types, you can use inheritance and polymorphism. You can create a superclass (e.g., MediaItem) that implements Comparable with a generic ordering rule (e.g., by title), and then subclass it for specific types of media (e.g., DVD) where you override the compareTo() method to implement the specific ordering rule for that type.